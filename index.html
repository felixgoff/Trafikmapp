<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Train Positions â€“ Lund</title>
  <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
  <style>

    body, html { margin:0; padding:0; height:100%;background-color: rgb(26, 26, 26); }
    #map { width:100%; height:100%; }

    .maplibregl-popup-content {
      overflow-x: auto;
      font-size: 13px;
    }
    .maplibregl-ctrl-bottom-right {
      display: none; /* Hide the MapLibre logo */
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    // Center on Lund, Sweden
    const map = new maplibregl.Map({
      container: 'map',
      style: './alidade_smooth.json', // Replace with your style URL or JSON
      center: [13.191, 55.704], // lon, lat for Lund
      projection: {"type": "globe"},
      zoom: 11
    });

    // Source + layer for train positions
    map.on('load', () => {
      map.addSource('trains', {
        type: 'geojson',
        data: { type:'FeatureCollection', features: [] }
      });

      map.addLayer({
        id: 'train-points',
        type: 'circle',
        source: 'trains',
        paint: {
          'circle-radius': 6,
          'circle-color': ['get', 'color'],
          'circle-stroke-width': 1,
          'circle-stroke-color': '#fff'
        }
      });

      // Add popup on train click
      map.on('click', 'train-points', (e) => {
        const feature = e.features[0];
        const props = feature.properties;
        // Format all properties as a table, skipping very long values
        let html = `<h3>${props.desc} ${props.OperationalTrainNumber}</h3>
        <table style="max-width:350px;word-break:break-word;font-size:13px">
        <tr><td style="vertical-align:top;"><strong>Route</strong></td><td style="vertical-align:top;">${props.route}</td></tr>
        <tr><td style="vertical-align:top;"><strong>Speed</strong></td><td style="vertical-align:top;">${props.speed}</td></tr>
        </table>`;

        new maplibregl.Popup({ maxWidth: '400px' })
          .setLngLat(feature.geometry.coordinates)
          .setHTML(html)
          .addTo(map);
      });

      // Change cursor to pointer when hovering train points
      map.on('mouseenter', 'train-points', () => {
        map.getCanvas().style.cursor = 'pointer';
      });
      map.on('mouseleave', 'train-points', () => {
        map.getCanvas().style.cursor = '';
      });

      // Add an arrow icon as a data URI (SVG)
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><polygon points="32,0 64,56 32,30 0,56" fill="white"/></svg>`;
        const img = new Image();
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        img.onload = () => {
            map.addImage('train-arrow', img, { sdf: false });
            map.addLayer({
                id: 'train-arrows',
                type: 'symbol',
                source: 'trains',
                layout: {
                'icon-image': 'train-arrow',
                'icon-size': 0.2, // Make arrow smaller than the circle
                'icon-rotate': ['get', 'bearing'],
                'icon-rotation-alignment': 'map',
                'icon-allow-overlap': true,
                'icon-offset': [0, -25] // Move arrow tip to the edge of the circle
                },
                paint: {
                'icon-opacity': 1
                }
            });
        };

        // Add camera icon to the map (PNG from Trafikverket)
        async function addCameraIcon() {
          const response = await fetch('./trafficCamera.png');
          const blob = await response.blob();
          const img = new Image();
          img.src = URL.createObjectURL(blob);
          await img.decode();
          map.addImage('camera-icon', img, { sdf: false });
        }
        addCameraIcon();

        // Camera data SSE and map
        map.addSource('cameras', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });

        map.addLayer({
          id: 'camera-points',
          type: 'symbol',
          source: 'cameras',
          layout: {
            'icon-image': 'camera-icon',
            'icon-size': 0.2,
            'icon-allow-overlap': true
          }
        });

        // Optional: popup on camera click
        map.on('click', 'camera-points', (e) => {
          const feature = e.features[0];
          const props = feature.properties;
          let html = `<h3>${props.Name || "Camera"}</h3>`;
          if (props.PhotoUrlThumbnail) {
            html += `<img src="${props.PhotoUrlThumbnail}" style="max-width:200px;display:block;margin-bottom:8px;">`;
          }
          const time = get_time_diff(props.PhotoTime);
          html += `<div><strong>Time:</strong> ${time || "Unknown"}</div>`;
          html += `<div><strong>Type:</strong> ${props.Type || ""}</div>`;
          html += `<div><a href="${props.PhotoUrlFullsize || props.PhotoUrl}" target="_blank">Fullsize Image</a></div>`;
          new maplibregl.Popup({ maxWidth: '250px' })
            .setLngLat(feature.geometry.coordinates)
            .setHTML(html)
            .addTo(map);
        });

        map.on('mouseenter', 'camera-points', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'camera-points', () => {
          map.getCanvas().style.cursor = '';
        });

      // Update camera source
    });
    function get_time_diff( datetime )
    {
        if (!datetime) return "N/a";

        var datetime = new Date( datetime ).getTime();
        var now = new Date().getTime();

        if( isNaN(datetime) )
        {
            return "";
        }

        console.log( datetime + " " + now);

        if (datetime < now) {
            var milisec_diff = now - datetime;
        }else{
            var milisec_diff = datetime - now;
        }

        var days = Math.floor(milisec_diff / 1000 / 60 / (60 * 24));

        var date_diff = new Date( milisec_diff );

        return days + " Days "+ date_diff.getHours() + " Hours " + date_diff.getMinutes() + " Minutes " + date_diff.getSeconds() + " Seconds";
    }
    function updateCameraLayer() {
        const features = Array.from(cameraMap.values());
        const geojson = { type: 'FeatureCollection', features };
        const src = map.getSource('cameras');
        if (src)src.setData(geojson);
    }
    const cameraMap = new Map();
        const esCamera = new EventSource("https://api.trafikinfo.trafikverket.se/v2/data.json?ssereqid=8d02610c-7e8c-433e-aa1c-22a906cf150c");

        esCamera.onmessage = (event) => {
          try {
            const payload = JSON.parse(event.data);
            const cameras = payload.RESPONSE.RESULT[0].Camera || [];
            cameras.forEach(cam => {
              if (!cam.Geometry || !cam.Geometry.WGS84) return;
              const match = cam.Geometry.WGS84.match(/POINT \(([-\d.]+) ([-\d.]+)\)/);
              const lon = match ? parseFloat(match[1]) : null;
              const lat = match ? parseFloat(match[2]) : null;
              cameraMap.set(cam.Id, {
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [lon, lat] },
                properties: { ...cam }
              });
            });
            updateCameraLayer();
          } catch (err) {
            console.error("Camera SSE error:", err);
          }
        };

    // Store all trains by OperationalTrainNumber
    const trainMap = new Map();

    // SSE for TrainPosition
    const esPosition = new EventSource("https://api.trafikinfo.trafikverket.se/v2/data.json?ssereqid=8a452d0f-340d-47c4-9bba-4bf7dee4fc1d");
    // SSE for TrainAnnouncement
    const esAnnouncement = new EventSource("https://api.trafikinfo.trafikverket.se/v2/data.json?ssereqid=2d1bec67-5fe4-4051-a11f-839a884a2ea1");

    // Handle TrainPosition updates
    esPosition.onmessage = (event) => {
      try {
        const payload = JSON.parse(event.data);
        const now = Date.now();

        payload.RESPONSE.RESULT[0].TrainPosition.forEach(tp => {
          const opNum = tp.Train?.OperationalTrainNumber;
          if (!opNum) return;
          // If train already exists, update position and timestamp, keep verification and announcement
          if (trainMap.has(opNum)) {
            const existing = trainMap.get(opNum);
            trainMap.set(opNum, {
              ...existing,
              tp,
              lastPositionTime: new Date(tp.TimeStamp).getTime()
            });
          } else {
            trainMap.set(opNum, {
              tp,
              verified: false,
              announcement: null,
              lastAnnouncementTime: null,
              lastPositionTime: new Date(tp.TimeStamp).getTime()
            });
          }
        });

        cleanupAndUpdate();
      } catch (err) {
        console.error("Bad data:", event.data, err);
      }
    };

    // Handle TrainAnnouncement updates
    esAnnouncement.onmessage = (event) => {
      try {
        const payload = JSON.parse(event.data);
        const now = Date.now();
        const announcements = payload.RESPONSE.RESULT[0].TrainAnnouncement || [];

        announcements.forEach(ta => {
          const opNum = ta.OperationalTrainNumber;
          if (!opNum) return;
          if (trainMap.has(opNum)) {
            // Mark as verified and attach announcement
            const existing = trainMap.get(opNum);
            trainMap.set(opNum, {
              ...existing,
              verified: true,
              announcement: ta,
              lastAnnouncementTime: now
            });
          } else {
            // If position hasn't arrived yet, create a placeholder (not shown until position arrives)
            trainMap.set(opNum, {
              tp: null,
              verified: true,
              announcement: ta,
              lastAnnouncementTime: now,
              lastPositionTime: null
            });
          }
        });

        cleanupAndUpdate();
      } catch (err) {
        console.error("Bad announcement data:", event.data, err);
      }
    };

    // Remove trains not verified in last 3 minutes and update map
    function cleanupAndUpdate() {
      const now = Date.now();
      for (const [opNum, train] of trainMap.entries()) {
        // Remove if last announcement is older than 3 minutes
        if (train.verified && train.lastAnnouncementTime && (now - train.lastAnnouncementTime > 3 * 60 * 1000)) {
          trainMap.delete(opNum);
          continue;
        }
        // Remove if last position is older than 3 minutes
        if (train.lastPositionTime && (now - train.lastPositionTime > 3 * 60 * 1000)) {
          trainMap.delete(opNum);
          continue;
        }
      }
      updateMap();
    }

    // Load stations.json and build a lookup map
    let stationNameMap = {};
    fetch('./stations.json')
      .then(res => res.json())
      .then(stations => {
        // Build a map: LocationSignature => AdvertisedLocationName
        stationNameMap = Object.fromEntries(
          stations.TrainStation.map(st => [st.LocationSignature, st.AdvertisedLocationName])
        );
        // Optionally, trigger updateMap() if you want to refresh after stations load
        updateMap();
      });

    // Only display trains that are verified and have position
    function updateMap() {
      const features = Array.from(trainMap.values())
        .filter(train => train.verified && train.tp && train.announcement)
        .map(train => {
          const tp = train.tp;
          const ta = train.announcement;
          const match = tp.Position.WGS84.match(/POINT \(([-\d.]+) ([-\d.]+)\)/);
          const lon = match ? parseFloat(match[1]) : null;
          const lat = match ? parseFloat(match[2]) : null;
          var color = "#FFFFFF";
          const desc = (ta.ProductInformation && ta.ProductInformation.length > 0 && ta.ProductInformation[0].Description) ? ta.ProductInformation[0].Description : "Train";
          switch (desc) {
            case "PÃ¥gatÃ¥gen":
              color = "#716cb8";
              break;
            case "Ã–resundstÃ¥g":
              color = "#706c6a";
              break;
            case "SJ SnabbtÃ¥g":
              color = "#277f46";
          }

          // Helper to get advertised name
          function getAdvertisedName(sig) {
            return stationNameMap[sig] || sig;
          }

          // Build route string with advertised names
          let route = "N/a";
          if (ta.ViaToLocation && ta.ViaToLocation.length > 0) {
            route = ta.ViaToLocation.map(v => getAdvertisedName(v.LocationName)).join(" â†’ ");
          } else if (ta.ToLocation && ta.ToLocation.length > 0) {
            route = getAdvertisedName(ta.ToLocation[0].LocationName);
          }

          const props = {
            ...tp,
            ...ta,
            id: tp.Train?.OperationalTrainNumber || null,
            advertisedTrainNumber: tp.Train?.AdvertisedTrainNumber || null,
            speed: (tp.Speed !== undefined && tp.Speed !== null) ? tp.Speed + "km/h" : "N/a",
            bearing: tp.Bearing,
            timeStamp: tp.TimeStamp,
            active: tp.Status?.Active,
            desc: desc,
            color: color,
            route: route
          };
          return {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [lon, lat]
            },
            properties: props
          };
        });

      const geojson = { type:'FeatureCollection', features };
      const src = map.getSource('trains');
      if (src) src.setData(geojson);
    }
  </script>
</body>
</html>
